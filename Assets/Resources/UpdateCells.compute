// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

RWTexture2D<float4> result;
Texture2D last_update;

RWTexture2D<float4> material_map;
Texture2D last_material_map;

float cell_width;
float cell_height;

float screen_width;
float screen_height;



void set_cell(const uint2 position, const float4 color, const float4 material)
{
    result[position] = color;
    material_map[position] = material;
}
bool within_bounds_y(const uint y)
{
    return y > 0 && y < screen_height;
}
bool within_bounds_x(const uint x)
{
    return x > 0 && x < screen_width;
}
bool within_bounds(uint2 pos)
{
    return within_bounds_x(pos.x) && within_bounds_y(pos.y);
}
uint2 try_move(uint2 origin, uint2 direction, const uint magnitude)
{
    if (magnitude == 0)
    {
        return origin;
    }

    if (direction.x == 0 || direction.y == 0)
    {
        return origin;
    }

    for (uint i = magnitude; i > 0; i--)
    {
        const uint2 new_position = origin + uint2(direction.x * magnitude, direction.y * magnitude);
        
        if (direction.x == 0)
        {
            if (!within_bounds_y(new_position.y)) continue;
        } else if (direction.y == 0)
        {
            if (!within_bounds_x(new_position.x)) continue;
        } else
        {
            if (!within_bounds(new_position)) continue;
        }
        
        float4 color_at_position = last_update[new_position];
        
        if (color_at_position.a <= 0)
        {
            return new_position;
        }
    }

    return origin;
}
bool try_move_simple(const uint2 origin, uint2 direction, const float4 color, const float4 material)
{
    uint2 new_position = origin + direction;
    
    if (direction.x == 0)
    {
        if (!within_bounds_y(new_position.y)) return false;
    } else if (direction.y == 0)
    {
        if (!within_bounds_x(new_position.x)) return false;
    } else
    {
        if (!within_bounds(new_position)) return false;
    }

    float4 color_at_position = last_update[new_position];
        
    if (color_at_position.a <= 0)
    {
        set_cell(new_position, color, material);
        return true;
    }

    return false;
}
bool is_static(float4 material)
{
    return material.a == 0.25;
}
bool is_falling(float4 material)
{
    return material.a == 0.5;
}
bool is_liquid(float4 material)
{
    return material.a == 0.75;
}
bool is_gas(float4 material)
{
    return material.a == 1;
}



[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    const uint2 current_pos = id.xy;
    
    float4 current = last_update[current_pos];
    float4 material = last_material_map[current_pos];
    
    if (current.a <= 0) return;

    if (is_falling(material))
    {
        if (try_move_simple(current_pos, uint2(0, -1), current, material)) return;
        if (try_move_simple(current_pos, uint2(-1, -1), current, material)) return;
        if (try_move_simple(current_pos, uint2(1, -1), current, material)) return;
        set_cell(current_pos, current, material);
    } else if (is_liquid(material))
    {
        if (try_move_simple(current_pos, uint2(0, -1), current, material)) return;
        if (try_move_simple(current_pos, uint2(-1, -1), current, material)) return;
        if (try_move_simple(current_pos, uint2(1, -1), current, material)) return;
        // if (try_move_simple(current_pos, uint2(1, 0), current, material)) return;
        if (try_move_simple(current_pos, uint2(-1, 0), current, material)) return;
        set_cell(current_pos, current, material);
    } else
    {
        set_cell(current_pos, current, material);
    }
}